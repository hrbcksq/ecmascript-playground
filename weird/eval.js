
// Scope 
function makeAnActor() {
  var value;
  return function(action)  {
    eval(action);
    console.log(value);
  }
}

const actor = makeAnActor();
actor();
actor('value = 5');

// Dynamic Scope example
// В качестве компромисса стандарт языка стал развиваться
// по пути разделения на два варианта вызова функции eval.
// Вызов функции с идентификатором eval рассматривается
// как «прямой» вызов eval:
var x = 'global';
function directCall() {
  var x = 'local';
  return eval('x');
}

const directResult = directCall(); // local

// Другой тип вызова функции считается «непрямым»,
// при нем аргументы функции вычисляются в глобальной
// области видимости. Например, связывание функции eval
// с другим именем переменной и вызов ее с помощью альтер-
// нативного имени приводит к тому, что код теряет доступ
// к любой локальной области видимости:
var y = 'global';
function unDirectCall() {
  var y = 'local';
  var f = eval;
  return f('y');
}

const undirectResult = unDirectCall(); // global // error in nodejs // but it's ok in chrome/ff

// Точное определение прямого вызова eval зависит от
// весьма своеобразного языка, предлагаемого стандартом
// ECMAScript. Фактически, единственным синтаксисом,
// позволяющим осуществить прямой вызов eval, являет-
// ся переменная по имени eval, возможно, заключенная
// в круглые скобки (в любое их количество). Краткий
// способ записи непрямого вызова eval заключается в ис-
// пользовании оператора последовательного выполнения
// выражений (,) с очевидно ничего не значащим числовым
// литералом:
(0,eval)('');
// Как же работает этот весьма странный на вид вызов функ-
// ции? Числовой литерал 0 вычисляется, но его значение
// игнорируется, и следующее выражение вызывает функцию
// eval. Следовательно, код (0,eval) ведет себя почти так
// же, как обычный идентификатор eval, но с одним важным
// отличием: все выражение вызова рассматривается как
// непрямой вызов eval.